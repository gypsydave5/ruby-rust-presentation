<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url('https://fonts.googleapis.com/css?family=Fira+Sans:400,800');
      @import url('https://fonts.googleapis.com/css?family=Fira+Mono');

      body { font-family: 'Fira Sans'; }
      h1, h2, h3 {
        font-family: 'Fira Sans';
        font-weight: bold;
      }
      .remark-code, .remark-inline-code { font-family: 'Fira Code','Fira Mono'; }

      .logo { display: block; width: 100%; height: auto;}
      img {max-width: 100%; max-height: 100%; display: block; margin: 0 auto;}
      .center-image { width: 100%; height: 550px; display: block }

      ul {
        font-size: 32px;
      }

      .quiet {
        font-size: 50%
      }

      code {
        color: white;
        background-color: black;
        display: inline-block;
        border-radius: 5px;
        padding: 0 5px;
      }

      .green { color: green; }
      .red { color: red; }

    </style>
  </head>
  <body>
    <textarea id="source">

class: middle, center

# A Brief
### (and Incomplete)
# Introduction to Rust
### (for Rubyists)

---

## About Me

- Makers Academy August 2015
- Full Stack Developer Mergermarket ~2 years
- Working with NodeJS, Go and *not enough* Ruby
- Bit of a functional programming nut<br> .quiet[(but I don't bite)]
- Love learning new languages

---

class: center

# What is Rust?

--

.middle[## "Rust is a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety."]

---

![what does that mean?](https://media.giphy.com/media/pdQB12mDIHpeM/giphy.gif)

---

##History

- Started in 2006
- Mozilla sponsors in 2009
- Pre-alpha compiler released in 2012
- Rust 1.0: 2015
- Currently at 1.17.0
- New version every 6 weeks

---
### So... from Ruby...

```ruby
def say_hello_world
  hello_world = "Hello, world!"
  puts "Today I'd like to say: #{hello_world}"
end

hello_world
```
--
### ... to Rust.
```rust
fn say_hello_world() {
  let hello_world = "Hello, world!";
  println!("Today I'd like to say: {}", hello_world);
}

fn main() {
  say_hello_world();
}
```
---

##What's the same as Ruby?

--
- C-like `{}` (sorry, no `do/end`)
--

- There are functions (`def` is `fn`)
--

- `snake_case` variables / function names
---

##What's different to Ruby?
--

### (but maybe you've seen it somewhere else)
--

- Compiled (Java, C, C++, Go, Haskell, ...)
--

- Strongly typed (Java, C, C++, Go, ...)
--

- Pointers / Reference types (C, C++, Go)
--

- Module system (NodeJS)
--

- No garbage collector (C, C++)
--

- `main()` entry point (C, C++, Go, Java)
---

##What's different to Ruby?
### (but maybe you've seen it somewhere else)

- Traits (like typeclasses in Haskell, Scala)
--

- Not 'classically' Object Oriented (C, Go)
--

- Methods defined on structs (Go)
--

- Pattern matching (Haskell, Elixir)
--

- No `null` type (Haskell)
---

##What's unique to Rust?

---
class: center, middle
#OWNERSHIP

---
class: center
#1. No Garbage Collector
---
class: center
## What is a garbage collector?
---
class: center, middle
# In the beginning...

(a mass of undifferentiated memory locations)

---
class: center, middle
#THEN -
---
class: center
.center-image[ ![C](https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/The_C_Programming_Language_logo.svg/1200px-The_C_Programming_Language_logo.svg.png) ]
---
class: center, middle
#"Let there be STACK and HEAP Memory!"
---
### THE STACK
The memory your program is running in

(it's like a scratch pad or a working area)
### THE HEAP
The memory your program keeps long term data in

(it's like a massive... heap of things)

---
# Ruby puts things on the heap

```ruby
def get_me_a_sandwich size
  size += 1
  Sandwich.new size
end

sandwich = get_me_a_sandwich 5
```
Sandwich making function!
---
# Ruby puts things on the heap

```ruby
def get_me_a_sandwich size
  size += 1
* Sandwich.new size #The sandwich goes on the heap
end

sandwich = get_me_a_sandwich 5
```
The sandwich goes on the heap
---
# Ruby puts things on the heap

```ruby
def get_me_a_sandwich size
  size += 1
  Sandwich.new size #The sandwich goes on the heap
end

*sandwich = get_me_a_sandwich 5 #The very same sandwich
```
The sandwich is handed over - a reference to the sandwich on the heap.
---
# Ruby puts things on the heap

```ruby
def get_me_a_sandwich size
  size += 1
  Sandwich.new size #The sandwich goes on the heap
end

*sandwich = get_me_a_sandwich 5 #The very same sandwich
```
EVERYTHING in Ruby is a reference to something on the Heap
(but everything 'happens' on the Stack)

---
class: center
# This is a MASSIVE simplification

(but we're talking about Rust, not Memory Management in Ruby)
---
# But ...
```ruby
def make_a_million_sandwiches_but_only_give_me_one
  lots = 1_000_000

  lots.times do
    Sandwich.new 5
  end

  Sandwich.new 6
end
```
Let's make a million sandwiches!
---
# But ...
```ruby
def make_a_million_sandwiches_but_only_give_me_one
  lots = 1_000_000

  lots.times do
*   Sandwich.new 5 #Many sandwiches go on the heap
  end

  Sandwich.new 6
end
```
Many sandwiches go on the heap
---
# But ...
```ruby
def make_a_million_sandwiches_but_only_give_me_one
  lots = 1_000_000

  lots.times do
    Sandwich.new 5 #Many sandwiches go on the heap
  end

* Sandwich.new 6 #We only use one
end
```
But we use only one of them
---
class: center, middle
#Q: What happens to the heap of one million sandwiches?
---
class: center
#A: GARBAGE COLLECTOR
![garbage collector](http://p.fod4.com/p/media/1d46854405/riBbiE0kRAi8bMgHlp1K_Freakout.gif)

a process in the background that runs around tidying up after your program,
working out which bits of memory you don't need anymore.
---
class: center, middle
#Is there an alternative?
---
## Manual Memory Management (in C)
```c
  int *number;
  number = (int *)malloc(sizeof(int));
  *number = 55;
  free(number);
```
---
## Manual Memory Management (in C)
```c
  int *number;
* number = (int *)malloc(sizeof(int));
  *number = 55;
  free(number);
```
We make a bit of space on the heap just big enough to put an `int` in.
---
## Manual Memory Management (in C)
```c
  int *number;
  number = (int *)malloc(sizeof(int));
* *number = 55;
  free(number);
```
We put an `int` in it.
---
## Manual Memory Management (in C)
```c
  int *number;
  number = (int *)malloc(sizeof(int));
  *number = 55;
* free(number);
```
We free up that bit of memory - tidy up after ourselves, doing the job of the GC
---
#Q: So why not manually manage memory?
--

#A: Memory Leaks
---
## Garbage collector
  - .green[\++] Safer, no need for humans to free memory.
  - .red[\--] Slower, more of an overhead.

## Manual memory management
  - .green[\++] Faster, no time spent on freeing memory.
  - .red[\--] Prone to human incompetence.
---

---
class: center
#2. No `null` type
---

---
class: center
#3. Using Rust in your Ruby
---


```rust
fn fibonacci(n: u32) -> u32 {
  match n {
    0 => 0,
    1 => 1,
    _ => fibonacci(n - 1) + fibonacci(n - 2),
  }
}
```

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
    <script>
      var slideshow = remark.create({
        highlightStyle: 'monokai',
        highlightLines: true
      });
    </script>
  </body>
</html>